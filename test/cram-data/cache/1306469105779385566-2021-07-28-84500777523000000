[{"item":"<b>module</b> Data.<span class=name><s0>Bifunctor</s0></span>","package":{"name":"base","url":"https://hackage.haskell.org/package/base"},"url":"https://hackage.haskell.org/package/base/docs/Data-Bifunctor.html","docs":"","type":"module","module":{}},{"item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> p","package":{"name":"base","url":"https://hackage.haskell.org/package/base"},"url":"https://hackage.haskell.org/package/base/docs/Data-Bifunctor.html#t:Bifunctor","docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","type":"","module":{"name":"Data.Bifunctor","url":"https://hackage.haskell.org/package/base/docs/Data-Bifunctor.html"}},{"item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","package":{"name":"lens","url":"https://hackage.haskell.org/package/lens"},"url":"https://hackage.haskell.org/package/lens/docs/Control-Lens-Combinators.html#t:Bifunctor","docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","type":"","module":{"name":"Control.Lens.Combinators","url":"https://hackage.haskell.org/package/lens/docs/Control-Lens-Combinators.html"}},{"item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","package":{"name":"lens","url":"https://hackage.haskell.org/package/lens"},"url":"https://hackage.haskell.org/package/lens/docs/Control-Lens-Review.html#t:Bifunctor","docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","type":"","module":{"name":"Control.Lens.Review","url":"https://hackage.haskell.org/package/lens/docs/Control-Lens-Review.html"}},{"item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","package":{"name":"semigroupoids","url":"https://hackage.haskell.org/package/semigroupoids"},"url":"https://hackage.haskell.org/package/semigroupoids/docs/Data-Bifunctor-Apply.html#t:Bifunctor","docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","type":"","module":{"name":"Data.Bifunctor.Apply","url":"https://hackage.haskell.org/package/semigroupoids/docs/Data-Bifunctor-Apply.html"}},{"item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","package":{"name":"protolude","url":"https://hackage.haskell.org/package/protolude"},"url":"https://hackage.haskell.org/package/protolude/docs/Protolude.html#t:Bifunctor","docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","type":"","module":{"name":"Protolude","url":"https://hackage.haskell.org/package/protolude/docs/Protolude.html"}},{"item":"<b>module</b> Protolude.<span class=name><s0>Bifunctor</s0></span>","package":{"name":"protolude","url":"https://hackage.haskell.org/package/protolude"},"url":"https://hackage.haskell.org/package/protolude/docs/Protolude-Bifunctor.html","docs":"","type":"module","module":{}},{"item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> p","package":{"name":"protolude","url":"https://hackage.haskell.org/package/protolude"},"url":"https://hackage.haskell.org/package/protolude/docs/Protolude-Bifunctor.html#t:Bifunctor","docs":"","type":"","module":{"name":"Protolude.Bifunctor","url":"https://hackage.haskell.org/package/protolude/docs/Protolude-Bifunctor.html"}},{"item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","package":{"name":"diagrams-lib","url":"https://hackage.haskell.org/package/diagrams-lib"},"url":"https://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Prelude.html#t:Bifunctor","docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","type":"","module":{"name":"Diagrams.Prelude","url":"https://hackage.haskell.org/package/diagrams-lib/docs/Diagrams-Prelude.html"}},{"item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","package":{"name":"streaming","url":"https://hackage.haskell.org/package/streaming"},"url":"https://hackage.haskell.org/package/streaming/docs/Streaming.html#t:Bifunctor","docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","type":"","module":{"name":"Streaming","url":"https://hackage.haskell.org/package/streaming/docs/Streaming.html"}},{"item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","package":{"name":"base-prelude","url":"https://hackage.haskell.org/package/base-prelude"},"url":"https://hackage.haskell.org/package/base-prelude/docs/BasePrelude.html#t:Bifunctor","docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","type":"","module":{"name":"BasePrelude","url":"https://hackage.haskell.org/package/base-prelude/docs/BasePrelude.html"}},{"item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","package":{"name":"rio","url":"https://hackage.haskell.org/package/rio"},"url":"https://hackage.haskell.org/package/rio/docs/RIO-Prelude-Types.html#t:Bifunctor","docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","type":"","module":{"name":"RIO.Prelude.Types","url":"https://hackage.haskell.org/package/rio/docs/RIO-Prelude-Types.html"}},{"item":"<b>module</b> Data.<span class=name><s0>Bifunctor</s0></span>","package":{"name":"rerebase","url":"https://hackage.haskell.org/package/rerebase"},"url":"https://hackage.haskell.org/package/rerebase/docs/Data-Bifunctor.html","docs":"","type":"module","module":{}},{"item":"<b>module</b> Relude.Extra.<span class=name><s0>Bifunctor</s0></span>","package":{"name":"relude","url":"https://hackage.haskell.org/package/relude"},"url":"https://hackage.haskell.org/package/relude/docs/Relude-Extra-Bifunctor.html","docs":"Useful combinators for bifunctors inside functors. This set of\nfunctions is useful when you want to work with types like these ones:\n\n<pre>\nfoo :: IO (Either a b)\nbar :: IO (a, b)\n\nbaz :: Maybe (Either a b)\nqux :: Maybe (a, b)\n\ndoo :: (a, a)\ndee :: Either a a\n</pre>\n","type":"module","module":{}},{"item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","package":{"name":"relude","url":"https://hackage.haskell.org/package/relude"},"url":"https://hackage.haskell.org/package/relude/docs/Relude-Functor-Reexport.html#t:Bifunctor","docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","type":"","module":{"name":"Relude.Functor.Reexport","url":"https://hackage.haskell.org/package/relude/docs/Relude-Functor-Reexport.html"}},{"item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> p","package":{"name":"optics-core","url":"https://hackage.haskell.org/package/optics-core"},"url":"https://hackage.haskell.org/package/optics-core/docs/Optics-Internal-Bi.html#t:Bifunctor","docs":"Class for (covariant) bifunctors.\n","type":"","module":{"name":"Optics.Internal.Bi","url":"https://hackage.haskell.org/package/optics-core/docs/Optics-Internal-Bi.html"}},{"item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","package":{"name":"universum","url":"https://hackage.haskell.org/package/universum"},"url":"https://hackage.haskell.org/package/universum/docs/Universum-Functor-Reexport.html#t:Bifunctor","docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","type":"","module":{"name":"Universum.Functor.Reexport","url":"https://hackage.haskell.org/package/universum/docs/Universum-Functor-Reexport.html"}},{"item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","package":{"name":"foundation","url":"https://hackage.haskell.org/package/foundation"},"url":"https://hackage.haskell.org/package/foundation/docs/Foundation.html#t:Bifunctor","docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","type":"","module":{"name":"Foundation","url":"https://hackage.haskell.org/package/foundation/docs/Foundation.html"}},{"item":"<b>module</b> Foundation.Class.<span class=name><s0>Bifunctor</s0></span>","package":{"name":"foundation","url":"https://hackage.haskell.org/package/foundation"},"url":"https://hackage.haskell.org/package/foundation/docs/Foundation-Class-Bifunctor.html","docs":"Formally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n","type":"module","module":{}},{"item":"<b>module</b> Basement.Compat.<span class=name><s0>Bifunctor</s0></span>","package":{"name":"basement","url":"https://hackage.haskell.org/package/basement"},"url":"https://hackage.haskell.org/package/basement/docs/Basement-Compat-Bifunctor.html","docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<tt>Functor</tt>, a type constructor such as <tt>Either</tt> does not\nneed to be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <tt>Left</tt>\nvalue or the <tt>Right</tt> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n","type":"module","module":{}},{"item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","package":{"name":"basement","url":"https://hackage.haskell.org/package/basement"},"url":"https://hackage.haskell.org/package/basement/docs/Basement-Compat-Bifunctor.html#t:Bifunctor","docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","type":"","module":{"name":"Basement.Compat.Bifunctor","url":"https://hackage.haskell.org/package/basement/docs/Basement-Compat-Bifunctor.html"}},{"item":"<b>module</b> Fcf.Class.<span class=name><s0>Bifunctor</s0></span>","package":{"name":"first-class-families","url":"https://hackage.haskell.org/package/first-class-families"},"url":"https://hackage.haskell.org/package/first-class-families/docs/Fcf-Class-Bifunctor.html","docs":"Bifunctors.\n\nBifunctors are \"two-argument functors\".\n\nThis module is the type-level equivalent of <a>Data.Bifunctor</a>.\n","type":"module","module":{}},{"item":"<b>module</b> Rebase.Data.<span class=name><s0>Bifunctor</s0></span>","package":{"name":"rebase","url":"https://hackage.haskell.org/package/rebase"},"url":"https://hackage.haskell.org/package/rebase/docs/Rebase-Data-Bifunctor.html","docs":"","type":"module","module":{}},{"item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","package":{"name":"rebase","url":"https://hackage.haskell.org/package/rebase"},"url":"https://hackage.haskell.org/package/rebase/docs/Rebase-Prelude.html#t:Bifunctor","docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","type":"","module":{"name":"Rebase.Prelude","url":"https://hackage.haskell.org/package/rebase/docs/Rebase-Prelude.html"}},{"item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","package":{"name":"stack","url":"https://hackage.haskell.org/package/stack"},"url":"https://hackage.haskell.org/package/stack/docs/Stack-Prelude.html#t:Bifunctor","docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","type":"","module":{"name":"Stack.Prelude","url":"https://hackage.haskell.org/package/stack/docs/Stack-Prelude.html"}},{"item":"<b>module</b> Control.Monad.Trans.<span class=name><s0>Bifunctor</s0></span>","package":{"name":"transformers-bifunctors","url":"https://hackage.haskell.org/package/transformers-bifunctors"},"url":"https://hackage.haskell.org/package/transformers-bifunctors/docs/Control-Monad-Trans-Bifunctor.html","docs":"","type":"module","module":{}},{"item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> p","package":{"name":"linear-base","url":"https://hackage.haskell.org/package/linear-base"},"url":"https://hackage.haskell.org/package/linear-base/docs/Data-Bifunctor-Linear.html#t:Bifunctor","docs":"The Bifunctor class\n\n<h2>Laws</h2>\n\nIf <a>bimap</a> is supplied, then <tt><a>bimap</a> <a>id</a> <a>id</a>\n= <a>id</a></tt>\n\n<ul>\n<li>If <a>first</a> and <a>second</a> are supplied, then <tt>\n<a>first</a> <a>id</a> ≡ <a>id</a> <a>second</a> <a>id</a> ≡ <a>id</a>\n</tt></li>\n<li>If all are supplied, then @<a>bimap</a> f g = <a>first</a> f\n<a>.</a> <a>second</a> g</li>\n</ul>\n","type":"","module":{"name":"Data.Bifunctor.Linear","url":"https://hackage.haskell.org/package/linear-base/docs/Data-Bifunctor-Linear.html"}},{"item":"<b>module</b> Data.Bifunctor.Linear.Internal.<span class=name><s0>Bifunctor</s0></span>","package":{"name":"linear-base","url":"https://hackage.haskell.org/package/linear-base"},"url":"https://hackage.haskell.org/package/linear-base/docs/Data-Bifunctor-Linear-Internal-Bifunctor.html","docs":"","type":"module","module":{}},{"item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> p","package":{"name":"linear-base","url":"https://hackage.haskell.org/package/linear-base"},"url":"https://hackage.haskell.org/package/linear-base/docs/Data-Bifunctor-Linear-Internal-Bifunctor.html#t:Bifunctor","docs":"The Bifunctor class\n\n<h2>Laws</h2>\n\nIf <a>bimap</a> is supplied, then <tt><a>bimap</a> <a>id</a> <a>id</a>\n= <a>id</a></tt>\n\n<ul>\n<li>If <a>first</a> and <a>second</a> are supplied, then <tt>\n<a>first</a> <a>id</a> ≡ <a>id</a> <a>second</a> <a>id</a> ≡ <a>id</a>\n</tt></li>\n<li>If all are supplied, then @<a>bimap</a> f g = <a>first</a> f\n<a>.</a> <a>second</a> g</li>\n</ul>\n","type":"","module":{"name":"Data.Bifunctor.Linear.Internal.Bifunctor","url":"https://hackage.haskell.org/package/linear-base/docs/Data-Bifunctor-Linear-Internal-Bifunctor.html"}},{"item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","package":{"name":"intro","url":"https://hackage.haskell.org/package/intro"},"url":"https://hackage.haskell.org/package/intro/docs/Intro.html#t:Bifunctor","docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","type":"","module":{"name":"Intro","url":"https://hackage.haskell.org/package/intro/docs/Intro.html"}},{"item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","package":{"name":"loc","url":"https://hackage.haskell.org/package/loc"},"url":"https://hackage.haskell.org/package/loc/docs/Data-Loc-Internal-Prelude.html#t:Bifunctor","docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","type":"","module":{"name":"Data.Loc.Internal.Prelude","url":"https://hackage.haskell.org/package/loc/docs/Data-Loc-Internal-Prelude.html"}},{"item":"<b>module</b> TextShow.Data.<span class=name><s0>Bifunctor</s0></span>","package":{"name":"text-show-instances","url":"https://hackage.haskell.org/package/text-show-instances"},"url":"https://hackage.haskell.org/package/text-show-instances/docs/TextShow-Data-Bifunctor.html","docs":"<a>TextShow</a> instances for data types in the <tt>bifunctors</tt>\nlibrary.\n\n<i>Since: 2</i>\n","type":"module","module":{}},{"item":"<b>module</b> Data.Quiver.<span class=name><s0>Bifunctor</s0></span>","package":{"name":"free-categories","url":"https://hackage.haskell.org/package/free-categories"},"url":"https://hackage.haskell.org/package/free-categories/docs/Data-Quiver-Bifunctor.html","docs":"The category of quivers forms a closed monoidal category in two ways,\nunder <a>ProductQ</a> or <a>ComposeQ</a>. The relations between these\nand their adjoints can be characterized by typeclasses below.\n","type":"module","module":{}},{"item":"<b>class</b> <span class=name><s0>Bifunctor</s0></span> (p :: Type -&gt; Type -&gt; Type)","package":{"name":"hledger-web","url":"https://hackage.haskell.org/package/hledger-web"},"url":"https://hackage.haskell.org/package/hledger-web/docs/Hledger-Web-Import.html#t:Bifunctor","docs":"A bifunctor is a type constructor that takes two type arguments and is\na functor in <i>both</i> arguments. That is, unlike with\n<a>Functor</a>, a type constructor such as <a>Either</a> does not need\nto be partially applied for a <a>Bifunctor</a> instance, and the\nmethods in this class permit mapping functions over the <a>Left</a>\nvalue or the <a>Right</a> value, or both at the same time.\n\nFormally, the class <a>Bifunctor</a> represents a bifunctor from\n<tt>Hask</tt> -&gt; <tt>Hask</tt>.\n\nIntuitively it is a bifunctor where both the first and second\narguments are covariant.\n\nYou can define a <a>Bifunctor</a> by either defining <a>bimap</a> or\nby defining both <a>first</a> and <a>second</a>.\n\nIf you supply <a>bimap</a>, you should ensure that:\n\n<pre>\n<a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <a>first</a> and <a>second</a>, ensure:\n\n<pre>\n<a>first</a> <a>id</a> ≡ <a>id</a>\n<a>second</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i\n<a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g\n<a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g\n</pre>\n","type":"","module":{"name":"Hledger.Web.Import","url":"https://hackage.haskell.org/package/hledger-web/docs/Hledger-Web-Import.html"}},{"item":"<b>package</b> <span class=name><s0>bifunctor</s0></span>","package":{},"url":"https://hackage.haskell.org/package/bifunctor","docs":"Not on Stackage, so not searched.\nBifunctors\n","type":"package","module":{}},{"item":"<b>class</b> BifunctorFunctor t =&gt; <span class=name><s0>BifunctorComonad</s0></span> t","package":{"name":"bifunctors","url":"https://hackage.haskell.org/package/bifunctors"},"url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-Functor.html#t:BifunctorComonad","docs":"","type":"","module":{"name":"Data.Bifunctor.Functor","url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-Functor.html"}},{"item":"<b>class</b> <span class=name><s0>BifunctorFunctor</s0></span> t","package":{"name":"bifunctors","url":"https://hackage.haskell.org/package/bifunctors"},"url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-Functor.html#t:BifunctorFunctor","docs":"","type":"","module":{"name":"Data.Bifunctor.Functor","url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-Functor.html"}},{"item":"<b>class</b> BifunctorFunctor t =&gt; <span class=name><s0>BifunctorMonad</s0></span> t","package":{"name":"bifunctors","url":"https://hackage.haskell.org/package/bifunctors"},"url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-Functor.html#t:BifunctorMonad","docs":"","type":"","module":{"name":"Data.Bifunctor.Functor","url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-Functor.html"}},{"item":"<b>class</b> <span class=name><s0>BifunctorTrans</s0></span> t","package":{"name":"transformers-bifunctors","url":"https://hackage.haskell.org/package/transformers-bifunctors"},"url":"https://hackage.haskell.org/package/transformers-bifunctors/docs/Control-Monad-Trans-Bifunctor.html#t:BifunctorTrans","docs":"Class of monad transformers which are bifunctors.\n\nYou can implement a <a>BifunctorTrans</a> by either defining\n<a>bimapT</a> or by defining both <a>firstT</a> and <a>secondT</a>.\n\nIf you supply <a>bimapT</a>, you should ensure that:\n\n<pre>\n<a>bimapT</a> <a>id</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply <tt>first</tt> and <tt>second</tt>, ensure:\n\n<pre>\n<a>firstT</a>  <a>id</a> ≡ <a>id</a>\n<a>secondT</a> <a>id</a> ≡ <a>id</a>\n</pre>\n\nIf you supply both, you should also ensure:\n\n<pre>\n<a>bimapT</a> f g ≡ <a>firstT</a> f <a>.</a> <a>secondT</a> g\n</pre>\n\nThese ensure by parametricity:\n\n<pre>\n<a>bimapT</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimapT</a> f h <a>.</a> <a>bimapT</a> g i\n<a>firstT</a>  (f <a>.</a> g) ≡ <a>firstT</a>  f <a>.</a> <a>firstT</a>  g\n<a>secondT</a> (f <a>.</a> g) ≡ <a>secondT</a> f <a>.</a> <a>secondT</a> g\n</pre>\n","type":"","module":{"name":"Control.Monad.Trans.Bifunctor","url":"https://hackage.haskell.org/package/transformers-bifunctors/docs/Control-Monad-Trans-Bifunctor.html"}},{"item":"<b>class</b> <span class=name><s0>BifunctorOf</s0></span> cat t","package":{"name":"generic-functor","url":"https://hackage.haskell.org/package/generic-functor"},"url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor-Internal-Implicit.html#t:BifunctorOf","docs":"","type":"","module":{"name":"Generic.Functor.Internal.Implicit","url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor-Internal-Implicit.html"}},{"item":"<b>package</b> <span class=name><s0>bifunctors</s0></span>","package":{},"url":"https://hackage.haskell.org/package/bifunctors","docs":"Bifunctors\n\nBifunctors.\n","type":"package","module":{}},{"item":"<span class=name><s0>deriveBifunctor</s0></span> :: Name -&gt; Q [Dec]","package":{"name":"bifunctors","url":"https://hackage.haskell.org/package/bifunctors"},"url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-TH.html#v:deriveBifunctor","docs":"Generates a <a>Bifunctor</a> instance declaration for the given data\ntype or data family instance.\n","type":"","module":{"name":"Data.Bifunctor.TH","url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-TH.html"}},{"item":"<span class=name><s0>deriveBifunctorOptions</s0></span> :: Options -&gt; Name -&gt; Q [Dec]","package":{"name":"bifunctors","url":"https://hackage.haskell.org/package/bifunctors"},"url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-TH.html#v:deriveBifunctorOptions","docs":"Like <a>deriveBifunctor</a>, but takes an <a>Options</a> argument.\n","type":"","module":{"name":"Data.Bifunctor.TH","url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-TH.html"}},{"item":"<span class=name><s0>WrapBifunctor</s0></span> :: p a b -&gt; WrappedBifunctor p a b","package":{"name":"bifunctors","url":"https://hackage.haskell.org/package/bifunctors"},"url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-Wrapped.html#v:WrapBifunctor","docs":"","type":"","module":{"name":"Data.Bifunctor.Wrapped","url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-Wrapped.html"}},{"item":"<b>newtype</b> <span class=name><s0>WrappedBifunctor</s0></span> p a b","package":{"name":"bifunctors","url":"https://hackage.haskell.org/package/bifunctors"},"url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-Wrapped.html#t:WrappedBifunctor","docs":"Make a <a>Functor</a> over the second argument of a <a>Bifunctor</a>.\n","type":"","module":{"name":"Data.Bifunctor.Wrapped","url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-Wrapped.html"}},{"item":"<span class=name><s0>unwrapBifunctor</s0></span> :: WrappedBifunctor p a b -&gt; p a b","package":{"name":"bifunctors","url":"https://hackage.haskell.org/package/bifunctors"},"url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-Wrapped.html#v:unwrapBifunctor","docs":"","type":"","module":{"name":"Data.Bifunctor.Wrapped","url":"https://hackage.haskell.org/package/bifunctors/docs/Data-Bifunctor-Wrapped.html"}},{"item":"<span class=name><s0>WrapBifunctor</s0></span> :: p a b -&gt; WrappedBifunctor","package":{"name":"invariant","url":"https://hackage.haskell.org/package/invariant"},"url":"https://hackage.haskell.org/package/invariant/docs/Data-Functor-Invariant.html#v:WrapBifunctor","docs":"","type":"","module":{"name":"Data.Functor.Invariant","url":"https://hackage.haskell.org/package/invariant/docs/Data-Functor-Invariant.html"}},{"item":"<b>newtype</b> <span class=name><s0>WrappedBifunctor</s0></span> (p :: k -&gt; k1 -&gt; Type) (a :: k) (b :: k1)","package":{"name":"invariant","url":"https://hackage.haskell.org/package/invariant"},"url":"https://hackage.haskell.org/package/invariant/docs/Data-Functor-Invariant.html#t:WrappedBifunctor","docs":"Make a <a>Functor</a> over the second argument of a <a>Bifunctor</a>.\n","type":"","module":{"name":"Data.Functor.Invariant","url":"https://hackage.haskell.org/package/invariant/docs/Data-Functor-Invariant.html"}},{"item":"<span class=name><s0>invmap2Bifunctor</s0></span> :: Bifunctor f =&gt; (a -&gt; c) -&gt; (c -&gt; a) -&gt; (b -&gt; d) -&gt; (d -&gt; b) -&gt; f a b -&gt; f c d","package":{"name":"invariant","url":"https://hackage.haskell.org/package/invariant"},"url":"https://hackage.haskell.org/package/invariant/docs/Data-Functor-Invariant.html#v:invmap2Bifunctor","docs":"Every <a>Bifunctor</a> is also an <a>Invariant2</a> functor.\n","type":"","module":{"name":"Data.Functor.Invariant","url":"https://hackage.haskell.org/package/invariant/docs/Data-Functor-Invariant.html"}},{"item":"<span class=name><s0>unwrapBifunctor</s0></span> :: WrappedBifunctor -&gt; p a b","package":{"name":"invariant","url":"https://hackage.haskell.org/package/invariant"},"url":"https://hackage.haskell.org/package/invariant/docs/Data-Functor-Invariant.html#v:unwrapBifunctor","docs":"","type":"","module":{"name":"Data.Functor.Invariant","url":"https://hackage.haskell.org/package/invariant/docs/Data-Functor-Invariant.html"}},{"item":"<b>package</b> <span class=name><s0>transformers-bifunctors</s0></span>","package":{},"url":"https://hackage.haskell.org/package/transformers-bifunctors","docs":"Bifunctors over monad transformers.\n\nBifunctors over monad transformers.\n","type":"package","module":{}},{"item":"<b>package</b> <span class=name><s0>papa-bifunctors-export</s0></span>","package":{},"url":"https://hackage.haskell.org/package/papa-bifunctors-export","docs":"Not on Stackage, so not searched.\nexport useful functions from `bifunctors`.\n","type":"package","module":{}},{"item":"<b>package</b> <span class=name><s0>papa-bifunctors-implement</s0></span>","package":{},"url":"https://hackage.haskell.org/package/papa-bifunctors-implement","docs":"Not on Stackage, so not searched.\nuseful `bifunctors` functions reimplemented\n","type":"package","module":{}},{"item":"<b>class</b> <span class=name><s0>HBifunctor</s0></span> (t :: (k -&gt; Type) -&gt; (k -&gt; Type) -&gt; k -&gt; Type)","package":{"name":"functor-combinators","url":"https://hackage.haskell.org/package/functor-combinators"},"url":"https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Combinator.html#t:HBifunctor","docs":"A <a>HBifunctor</a> is like an <a>HFunctor</a>, but it enhances\n<i>two</i> different functors instead of just one.\n\nUsually, it enhaces them \"together\" in some sort of combining way.\n\nThis typeclass provides a uniform instance for \"swapping out\" or\n\"hoisting\" the enhanced functors. We can hoist the first one with\n<a>hleft</a>, the second one with <a>hright</a>, or both at the same\ntime with <a>hbimap</a>.\n\nFor example, the <tt>f :*: g</tt> type gives us \"both <tt>f</tt> and\n<tt>g</tt>\":\n\n<pre>\ndata (f <a>:*:</a> g) a = f a :*: g a\n</pre>\n\nIt combines both <tt>f</tt> and <tt>g</tt> into a unified structure\n--- here, it does it by providing both <tt>f</tt> and <tt>g</tt>.\n\nThe single law is:\n\n<pre>\n<a>hbimap</a> <a>id</a> id == id\n</pre>\n\nThis ensures that <a>hleft</a>, <a>hright</a>, and <a>hbimap</a> do\nnot affect the structure that <tt>t</tt> adds on top of the underlying\nfunctors.\n","type":"","module":{"name":"Data.Functor.Combinator","url":"https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Combinator.html"}},{"item":"<b>module</b> Data.<span class=name><s0>HBifunctor</s0></span>","package":{"name":"functor-combinators","url":"https://hackage.haskell.org/package/functor-combinators"},"url":"https://hackage.haskell.org/package/functor-combinators/docs/Data-HBifunctor.html","docs":"This module provides an abstraction for \"two-argument functor\ncombinators\", <a>HBifunctor</a>, as well as some useful combinators.\n","type":"module","module":{}},{"item":"<b>class</b> <span class=name><s0>HBifunctor</s0></span> (t :: (k -&gt; Type) -&gt; (k -&gt; Type) -&gt; k -&gt; Type)","package":{"name":"functor-combinators","url":"https://hackage.haskell.org/package/functor-combinators"},"url":"https://hackage.haskell.org/package/functor-combinators/docs/Data-HBifunctor.html#t:HBifunctor","docs":"A <a>HBifunctor</a> is like an <a>HFunctor</a>, but it enhances\n<i>two</i> different functors instead of just one.\n\nUsually, it enhaces them \"together\" in some sort of combining way.\n\nThis typeclass provides a uniform instance for \"swapping out\" or\n\"hoisting\" the enhanced functors. We can hoist the first one with\n<a>hleft</a>, the second one with <a>hright</a>, or both at the same\ntime with <a>hbimap</a>.\n\nFor example, the <tt>f :*: g</tt> type gives us \"both <tt>f</tt> and\n<tt>g</tt>\":\n\n<pre>\ndata (f <a>:*:</a> g) a = f a :*: g a\n</pre>\n\nIt combines both <tt>f</tt> and <tt>g</tt> into a unified structure\n--- here, it does it by providing both <tt>f</tt> and <tt>g</tt>.\n\nThe single law is:\n\n<pre>\n<a>hbimap</a> <a>id</a> id == id\n</pre>\n\nThis ensures that <a>hleft</a>, <a>hright</a>, and <a>hbimap</a> do\nnot affect the structure that <tt>t</tt> adds on top of the underlying\nfunctors.\n","type":"","module":{"name":"Data.HBifunctor","url":"https://hackage.haskell.org/package/functor-combinators/docs/Data-HBifunctor.html"}},{"item":"<span class=name><s0>WrapHBifunctor</s0></span> :: t f g a -&gt; WrappedHBifunctor t (f :: k -&gt; Type) (g :: k -&gt; Type) (a :: k)","package":{"name":"functor-combinators","url":"https://hackage.haskell.org/package/functor-combinators"},"url":"https://hackage.haskell.org/package/functor-combinators/docs/Data-HBifunctor.html#v:WrapHBifunctor","docs":"","type":"","module":{"name":"Data.HBifunctor","url":"https://hackage.haskell.org/package/functor-combinators/docs/Data-HBifunctor.html"}},{"item":"<b>newtype</b> <span class=name><s0>WrappedHBifunctor</s0></span> t (f :: k -&gt; Type) (g :: k -&gt; Type) (a :: k)","package":{"name":"functor-combinators","url":"https://hackage.haskell.org/package/functor-combinators"},"url":"https://hackage.haskell.org/package/functor-combinators/docs/Data-HBifunctor.html#t:WrappedHBifunctor","docs":"Useful newtype to allow us to derive an <a>HFunctor</a> instance from\nany instance of <a>HBifunctor</a>, using -XDerivingVia.\n\nFor example, because we have <tt>instance <a>HBifunctor</a>\n<a>Day</a></tt>, we can write:\n\n<pre>\nderiving via (<a>WrappedHBifunctor</a> <a>Day</a> f) instance <a>HFunctor</a> (<a>Day</a> f)\n</pre>\n\nto give us an automatic <a>HFunctor</a> instance and save us some\nwork.\n","type":"","module":{"name":"Data.HBifunctor","url":"https://hackage.haskell.org/package/functor-combinators/docs/Data-HBifunctor.html"}},{"item":"<span class=name><s0>overHBifunctor</s0></span> :: HBifunctor t =&gt; (f &lt;~&gt; f&#39;) -&gt; (g &lt;~&gt; g&#39;) -&gt; t f g &lt;~&gt; t f&#39; g&#39;","package":{"name":"functor-combinators","url":"https://hackage.haskell.org/package/functor-combinators"},"url":"https://hackage.haskell.org/package/functor-combinators/docs/Data-HBifunctor.html#v:overHBifunctor","docs":"Lift two isomorphisms on each side of a bifunctor to become an\nisomorphism between the two bifunctor applications.\n\nBasically, if <tt>f</tt> and <tt>f'</tt> are isomorphic, and\n<tt>g</tt> and <tt>g'</tt> are isomorphic, then <tt>t f g</tt> is\nisomorphic to <tt>t f' g'</tt>.\n","type":"","module":{"name":"Data.HBifunctor","url":"https://hackage.haskell.org/package/functor-combinators/docs/Data-HBifunctor.html"}},{"item":"<span class=name><s0>unwrapHBifunctor</s0></span> :: WrappedHBifunctor t (f :: k -&gt; Type) (g :: k -&gt; Type) (a :: k) -&gt; t f g a","package":{"name":"functor-combinators","url":"https://hackage.haskell.org/package/functor-combinators"},"url":"https://hackage.haskell.org/package/functor-combinators/docs/Data-HBifunctor.html#v:unwrapHBifunctor","docs":"","type":"","module":{"name":"Data.HBifunctor","url":"https://hackage.haskell.org/package/functor-combinators/docs/Data-HBifunctor.html"}},{"item":"<b>class</b> (GBimap f, GFirst f, GSecond f) =&gt; <span class=name><s0>GBifunctor</s0></span> f","package":{"name":"generic-functor","url":"https://hackage.haskell.org/package/generic-functor"},"url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor.html#t:GBifunctor","docs":"Generic <a>Bifunctor</a>.\n","type":"","module":{"name":"Generic.Functor","url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor.html"}},{"item":"<b>newtype</b> <span class=name><s0>GenericBifunctor</s0></span> f a b","package":{"name":"generic-functor","url":"https://hackage.haskell.org/package/generic-functor"},"url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor.html#t:GenericBifunctor","docs":"<tt>newtype</tt> for <tt>DerivingVia</tt> of <a>Bifunctor</a> and\n<a>Bifoldable</a> instances.\n\nNote: deriving <a>Bifunctor</a> for a generic type often requires\n<a>Functor</a> instances for types mentioned in the fields.\n\n<h3>Example</h3>\n\n<pre>\n{-# LANGUAGE DeriveGeneric, DerivingVia #-}\n\nimport <a>Data.Bifoldable</a> (<a>Bifoldable</a>)\nimport <a>Data.Bifunctor</a> (<a>Bifunctor</a>)\nimport <a>GHC.Generics</a> (<a>Generic</a>)\nimport <a>Generic.Functor</a> (<a>GenericFunctor</a>(..), <a>GenericBifunctor</a>(..))\n\ndata Tree a b = Node a (Tree a b) (Tree a b) | Leaf b\nderiving <a>Generic</a>\nderiving (<a>Functor</a>, <a>Foldable</a>) via (<a>GenericFunctor</a> (Tree a))\nderiving (<a>Bifunctor</a>, <a>Bifoldable</a>) via (<a>GenericBifunctor</a> Tree)\n\ndata CofreeF f a b = a :&lt; f b\nderiving <a>Generic</a>\nderiving (<a>Bifunctor</a>, <a>Bifoldable</a>) via (<a>GenericBifunctor</a> (CofreeF f))\n</pre>\n","type":"","module":{"name":"Generic.Functor","url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor.html"}},{"item":"<span class=name><s0>GenericBifunctor</s0></span> :: f a b -&gt; GenericBifunctor f a b","package":{"name":"generic-functor","url":"https://hackage.haskell.org/package/generic-functor"},"url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor.html#v:GenericBifunctor","docs":"","type":"","module":{"name":"Generic.Functor","url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor.html"}},{"item":"<b>class</b> (GBimap f, GFirst f, GSecond f) =&gt; <span class=name><s0>GBifunctor</s0></span> f","package":{"name":"generic-functor","url":"https://hackage.haskell.org/package/generic-functor"},"url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor-Internal.html#t:GBifunctor","docs":"Generic <a>Bifunctor</a>.\n","type":"","module":{"name":"Generic.Functor.Internal","url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor-Internal.html"}},{"item":"<b>newtype</b> <span class=name><s0>GenericBifunctor</s0></span> f a b","package":{"name":"generic-functor","url":"https://hackage.haskell.org/package/generic-functor"},"url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor-Internal.html#t:GenericBifunctor","docs":"<tt>newtype</tt> for <tt>DerivingVia</tt> of <a>Bifunctor</a> and\n<a>Bifoldable</a> instances.\n\nNote: deriving <a>Bifunctor</a> for a generic type often requires\n<a>Functor</a> instances for types mentioned in the fields.\n\n<h3>Example</h3>\n\n<pre>\n{-# LANGUAGE DeriveGeneric, DerivingVia #-}\n\nimport <a>Data.Bifoldable</a> (<a>Bifoldable</a>)\nimport <a>Data.Bifunctor</a> (<a>Bifunctor</a>)\nimport <a>GHC.Generics</a> (<a>Generic</a>)\nimport <a>Generic.Functor</a> (<a>GenericFunctor</a>(..), <a>GenericBifunctor</a>(..))\n\ndata Tree a b = Node a (Tree a b) (Tree a b) | Leaf b\nderiving <a>Generic</a>\nderiving (<a>Functor</a>, <a>Foldable</a>) via (<a>GenericFunctor</a> (Tree a))\nderiving (<a>Bifunctor</a>, <a>Bifoldable</a>) via (<a>GenericBifunctor</a> Tree)\n\ndata CofreeF f a b = a :&lt; f b\nderiving <a>Generic</a>\nderiving (<a>Bifunctor</a>, <a>Bifoldable</a>) via (<a>GenericBifunctor</a> (CofreeF f))\n</pre>\n","type":"","module":{"name":"Generic.Functor.Internal","url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor-Internal.html"}},{"item":"<span class=name><s0>GenericBifunctor</s0></span> :: f a b -&gt; GenericBifunctor f a b","package":{"name":"generic-functor","url":"https://hackage.haskell.org/package/generic-functor"},"url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor-Internal.html#v:GenericBifunctor","docs":"","type":"","module":{"name":"Generic.Functor.Internal","url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor-Internal.html"}},{"item":"<b>data</b> <span class=name><s0>AnyBifunctor</s0></span>","package":{"name":"generic-functor","url":"https://hackage.haskell.org/package/generic-functor"},"url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor-Internal-Implicit.html#t:AnyBifunctor","docs":"","type":"","module":{"name":"Generic.Functor.Internal.Implicit","url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor-Internal-Implicit.html"}},{"item":"<span class=name><s0>AnyBifunctor</s0></span> :: AnyBifunctor","package":{"name":"generic-functor","url":"https://hackage.haskell.org/package/generic-functor"},"url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor-Internal-Implicit.html#v:AnyBifunctor","docs":"","type":"","module":{"name":"Generic.Functor.Internal.Implicit","url":"https://hackage.haskell.org/package/generic-functor/docs/Generic-Functor-Internal-Implicit.html"}},{"item":"<b>package</b> <span class=name><s0>papa-bifunctors</s0></span>","package":{},"url":"https://hackage.haskell.org/package/papa-bifunctors","docs":"Not on Stackage, so not searched.\nPrelude with only useful functions\n","type":"package","module":{}}]