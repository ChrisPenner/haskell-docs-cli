[{"item":"<b>module</b> Data.<span class=name><s0>Map</s0></span>","package":{"name":"containers","url":"https://hackage.haskell.org/package/containers"},"url":"https://hackage.haskell.org/package/containers/docs/Data-Map.html","docs":"<i>Note:</i> You should use <a>Data.Map.Strict</a> instead of this\nmodule if:\n\n<ul>\n<li>You will eventually need all the values stored.</li>\n<li>The stored values don't represent large virtual data structures to\nbe lazily computed.</li>\n</ul>\n\nAn efficient implementation of ordered maps from keys to values\n(dictionaries).\n\nThese modules are intended to be imported qualified, to avoid name\nclashes with Prelude functions, e.g.\n\n<pre>\nimport qualified Data.Map as Map\n</pre>\n\nThe implementation of <a>Map</a> is based on <i>size balanced</i>\nbinary trees (or trees of <i>bounded balance</i>) as described by:\n\n<ul>\n<li>Stephen Adams, \"<i>Efficient sets: a balancing act</i>\", Journal\nof Functional Programming 3(4):553-562, October 1993,\n<a>http://www.swiss.ai.mit.edu/~adams/BB/</a>.</li>\n<li>J. Nievergelt and E.M. Reingold, \"<i>Binary search trees of\nbounded balance</i>\", SIAM journal of computing 2(1), March 1973.</li>\n</ul>\n\nBounds for <a>union</a>, <a>intersection</a>, and <a>difference</a>\nare as given by\n\n<ul>\n<li>Guy Blelloch, Daniel Ferizovic, and Yihan Sun, \"<i>Just Join for\nParallel Ordered Sets</i>\",\n<a>https://arxiv.org/abs/1602.02120v3</a>.</li>\n</ul>\n\nNote that the implementation is <i>left-biased</i> -- the elements of\na first argument are always preferred to the second, for example in\n<a>union</a> or <a>insert</a>.\n\n<i>Warning</i>: The size of the map must not exceed\n<tt>maxBound::Int</tt>. Violation of this condition is not detected\nand if the size limit is exceeded, its behaviour is undefined.\n\nOperation comments contain the operation time complexity in the Big-O\nnotation (<a>http://en.wikipedia.org/wiki/Big_O_notation</a>).\n","type":"module","module":{}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","package":{"name":"containers","url":"https://hackage.haskell.org/package/containers"},"url":"https://hackage.haskell.org/package/containers/docs/Data-Map-Internal.html#t:Map","docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n\nThe <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which\nprefers values from the left operand. If <tt>m1</tt> maps a key\n<tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key\nto a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;\nm2</tt> maps <tt>k</tt> to <tt>a1</tt>.\n","type":"","module":{"name":"Data.Map.Internal","url":"https://hackage.haskell.org/package/containers/docs/Data-Map-Internal.html"}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","package":{"name":"containers","url":"https://hackage.haskell.org/package/containers"},"url":"https://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#t:Map","docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n\nThe <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which\nprefers values from the left operand. If <tt>m1</tt> maps a key\n<tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key\nto a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;\nm2</tt> maps <tt>k</tt> to <tt>a1</tt>.\n","type":"","module":{"name":"Data.Map.Lazy","url":"https://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html"}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","package":{"name":"containers","url":"https://hackage.haskell.org/package/containers"},"url":"https://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#t:Map","docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n\nThe <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which\nprefers values from the left operand. If <tt>m1</tt> maps a key\n<tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key\nto a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;\nm2</tt> maps <tt>k</tt> to <tt>a1</tt>.\n","type":"","module":{"name":"Data.Map.Strict","url":"https://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html"}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","package":{"name":"containers","url":"https://hackage.haskell.org/package/containers"},"url":"https://hackage.haskell.org/package/containers/docs/Data-Map-Strict-Internal.html#t:Map","docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n\nThe <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which\nprefers values from the left operand. If <tt>m1</tt> maps a key\n<tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key\nto a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;\nm2</tt> maps <tt>k</tt> to <tt>a1</tt>.\n","type":"","module":{"name":"Data.Map.Strict.Internal","url":"https://hackage.haskell.org/package/containers/docs/Data-Map-Strict-Internal.html"}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","package":{"name":"Cabal","url":"https://hackage.haskell.org/package/Cabal"},"url":"https://hackage.haskell.org/package/Cabal/docs/Distribution-Compat-Prelude-Internal.html#t:Map","docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n\nThe <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which\nprefers values from the left operand. If <tt>m1</tt> maps a key\n<tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key\nto a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;\nm2</tt> maps <tt>k</tt> to <tt>a1</tt>.\n","type":"","module":{"name":"Distribution.Compat.Prelude.Internal","url":"https://hackage.haskell.org/package/Cabal/docs/Distribution-Compat-Prelude-Internal.html"}},{"item":"<b>module</b> Network.AWS.Data.<span class=name><s0>Map</s0></span>","package":{"name":"amazonka-core","url":"https://hackage.haskell.org/package/amazonka-core"},"url":"https://hackage.haskell.org/package/amazonka-core/docs/Network-AWS-Data-Map.html","docs":"","type":"module","module":{}},{"item":"<b>newtype</b> <span class=name><s0>Map</s0></span> k v","package":{"name":"amazonka-core","url":"https://hackage.haskell.org/package/amazonka-core"},"url":"https://hackage.haskell.org/package/amazonka-core/docs/Network-AWS-Data-Map.html#t:Map","docs":"","type":"","module":{"name":"Network.AWS.Data.Map","url":"https://hackage.haskell.org/package/amazonka-core/docs/Network-AWS-Data-Map.html"}},{"item":"<span class=name><s0>Map</s0></span> :: HashMap k v -&gt; Map k v","package":{"name":"amazonka-core","url":"https://hackage.haskell.org/package/amazonka-core"},"url":"https://hackage.haskell.org/package/amazonka-core/docs/Network-AWS-Data-Map.html#v:Map","docs":"","type":"","module":{"name":"Network.AWS.Data.Map","url":"https://hackage.haskell.org/package/amazonka-core/docs/Network-AWS-Data-Map.html"}},{"item":"<b>newtype</b> <span class=name><s0>Map</s0></span> k v","package":{"name":"amazonka-core","url":"https://hackage.haskell.org/package/amazonka-core"},"url":"https://hackage.haskell.org/package/amazonka-core/docs/Network-AWS-Prelude.html#t:Map","docs":"","type":"","module":{"name":"Network.AWS.Prelude","url":"https://hackage.haskell.org/package/amazonka-core/docs/Network-AWS-Prelude.html"}},{"item":"<span class=name><s0>Map</s0></span> :: HashMap k v -&gt; Map k v","package":{"name":"amazonka-core","url":"https://hackage.haskell.org/package/amazonka-core"},"url":"https://hackage.haskell.org/package/amazonka-core/docs/Network-AWS-Prelude.html#v:Map","docs":"","type":"","module":{"name":"Network.AWS.Prelude","url":"https://hackage.haskell.org/package/amazonka-core/docs/Network-AWS-Prelude.html"}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> k v","package":{"name":"uniplate","url":"https://hackage.haskell.org/package/uniplate"},"url":"https://hackage.haskell.org/package/uniplate/docs/Data-Generics-Uniplate-Data-Instances.html#t:Map","docs":"Invariant preserving version of <tt>Map</tt> from the\n<tt>containers</tt> packages, suitable for use with <tt>Uniplate</tt>.\nUse <a>toMap</a> to construct values, and <a>fromMap</a> to\ndeconstruct values.\n","type":"","module":{"name":"Data.Generics.Uniplate.Data.Instances","url":"https://hackage.haskell.org/package/uniplate/docs/Data-Generics-Uniplate-Data-Instances.html"}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","package":{"name":"protolude","url":"https://hackage.haskell.org/package/protolude"},"url":"https://hackage.haskell.org/package/protolude/docs/Protolude.html#t:Map","docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n","type":"","module":{"name":"Protolude","url":"https://hackage.haskell.org/package/protolude/docs/Protolude.html"}},{"item":"<b>module</b> Data.Convertible.Instances.<span class=name><s0>Map</s0></span>","package":{"name":"convertible","url":"https://hackage.haskell.org/package/convertible"},"url":"https://hackage.haskell.org/package/convertible/docs/Data-Convertible-Instances-Map.html","docs":"Instances to convert between Map and association list.\n\nCopyright (C) 2009-2011 John Goerzen <a>jgoerzen@complete.org</a>\n\nAll rights reserved.\n\nFor license and copyright information, see the file LICENSE\n","type":"module","module":{}},{"item":"<b>module</b> RIO.<span class=name><s0>Map</s0></span>","package":{"name":"rio","url":"https://hackage.haskell.org/package/rio"},"url":"https://hackage.haskell.org/package/rio/docs/RIO-Map.html","docs":"Strict <tt>Map</tt>. Import as:\n\n<pre>\nimport qualified RIO.Map as Map\n</pre>\n\nThis module does not export any partial or unchecked functions. For\nthose, see <a>RIO.Map.Partial</a> and <a>RIO.Map.Unchecked</a>\n","type":"module","module":{}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","package":{"name":"rio","url":"https://hackage.haskell.org/package/rio"},"url":"https://hackage.haskell.org/package/rio/docs/RIO-Map.html#t:Map","docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n\nThe <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which\nprefers values from the left operand. If <tt>m1</tt> maps a key\n<tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key\nto a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;\nm2</tt> maps <tt>k</tt> to <tt>a1</tt>.\n","type":"","module":{"name":"RIO.Map","url":"https://hackage.haskell.org/package/rio/docs/RIO-Map.html"}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","package":{"name":"rio","url":"https://hackage.haskell.org/package/rio"},"url":"https://hackage.haskell.org/package/rio/docs/RIO-Prelude-Types.html#t:Map","docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n\nThe <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which\nprefers values from the left operand. If <tt>m1</tt> maps a key\n<tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key\nto a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;\nm2</tt> maps <tt>k</tt> to <tt>a1</tt>.\n","type":"","module":{"name":"RIO.Prelude.Types","url":"https://hackage.haskell.org/package/rio/docs/RIO-Prelude-Types.html"}},{"item":"<b>module</b> Data.<span class=name><s0>Map</s0></span>","package":{"name":"rerebase","url":"https://hackage.haskell.org/package/rerebase"},"url":"https://hackage.haskell.org/package/rerebase/docs/Data-Map.html","docs":"","type":"module","module":{}},{"item":"<b>module</b> Dhall.<span class=name><s0>Map</s0></span>","package":{"name":"dhall","url":"https://hackage.haskell.org/package/dhall"},"url":"https://hackage.haskell.org/package/dhall/docs/Dhall-Map.html","docs":"<a>Map</a> type used to represent records and unions\n","type":"module","module":{}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> k v","package":{"name":"dhall","url":"https://hackage.haskell.org/package/dhall"},"url":"https://hackage.haskell.org/package/dhall/docs/Dhall-Map.html#t:Map","docs":"A <a>Map</a> that remembers the original ordering of keys\n\nThis is primarily used so that formatting preserves field order\n\nThis is done primarily to avoid a dependency on\n<tt>insert-ordered-containers</tt> and also to improve performance\n","type":"","module":{"name":"Dhall.Map","url":"https://hackage.haskell.org/package/dhall/docs/Dhall-Map.html"}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","package":{"name":"classy-prelude","url":"https://hackage.haskell.org/package/classy-prelude"},"url":"https://hackage.haskell.org/package/classy-prelude/docs/ClassyPrelude.html#t:Map","docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n","type":"","module":{"name":"ClassyPrelude","url":"https://hackage.haskell.org/package/classy-prelude/docs/ClassyPrelude.html"}},{"item":"<b>module</b> Data.NonEmpty.<span class=name><s0>Map</s0></span>","package":{"name":"non-empty","url":"https://hackage.haskell.org/package/non-empty"},"url":"https://hackage.haskell.org/package/non-empty/docs/Data-NonEmpty-Map.html","docs":"","type":"module","module":{}},{"item":"<b>module</b> StmContainers.<span class=name><s0>Map</s0></span>","package":{"name":"stm-containers","url":"https://hackage.haskell.org/package/stm-containers"},"url":"https://hackage.haskell.org/package/stm-containers/docs/StmContainers-Map.html","docs":"","type":"module","module":{}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> key value","package":{"name":"stm-containers","url":"https://hackage.haskell.org/package/stm-containers"},"url":"https://hackage.haskell.org/package/stm-containers/docs/StmContainers-Map.html#t:Map","docs":"Hash-table, based on STM-specialized Hash Array Mapped Trie.\n","type":"","module":{"name":"StmContainers.Map","url":"https://hackage.haskell.org/package/stm-containers/docs/StmContainers-Map.html"}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","package":{"name":"basic-prelude","url":"https://hackage.haskell.org/package/basic-prelude"},"url":"https://hackage.haskell.org/package/basic-prelude/docs/CorePrelude.html#t:Map","docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n","type":"","module":{"name":"CorePrelude","url":"https://hackage.haskell.org/package/basic-prelude/docs/CorePrelude.html"}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","package":{"name":"relude","url":"https://hackage.haskell.org/package/relude"},"url":"https://hackage.haskell.org/package/relude/docs/Relude-Container-Reexport.html#t:Map","docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n\nThe <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which\nprefers values from the left operand. If <tt>m1</tt> maps a key\n<tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key\nto a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;\nm2</tt> maps <tt>k</tt> to <tt>a1</tt>.\n","type":"","module":{"name":"Relude.Container.Reexport","url":"https://hackage.haskell.org/package/relude/docs/Relude-Container-Reexport.html"}},{"item":"<b>module</b> Relude.Extra.<span class=name><s0>Map</s0></span>","package":{"name":"relude","url":"https://hackage.haskell.org/package/relude"},"url":"https://hackage.haskell.org/package/relude/docs/Relude-Extra-Map.html","docs":"Contains implementation of polymorphic type classes for data types\n<a>Set</a> and <a>Map</a>.\n","type":"module","module":{}},{"item":"<b>module</b> Data.Dependent.<span class=name><s0>Map</s0></span>","package":{"name":"dependent-map","url":"https://hackage.haskell.org/package/dependent-map"},"url":"https://hackage.haskell.org/package/dependent-map/docs/Data-Dependent-Map.html","docs":"","type":"module","module":{}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","package":{"name":"universum","url":"https://hackage.haskell.org/package/universum"},"url":"https://hackage.haskell.org/package/universum/docs/Universum-Container-Reexport.html#t:Map","docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n\nThe <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which\nprefers values from the left operand. If <tt>m1</tt> maps a key\n<tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key\nto a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;\nm2</tt> maps <tt>k</tt> to <tt>a1</tt>.\n","type":"","module":{"name":"Universum.Container.Reexport","url":"https://hackage.haskell.org/package/universum/docs/Universum-Container-Reexport.html"}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span>","package":{"name":"first-class-families","url":"https://hackage.haskell.org/package/first-class-families"},"url":"https://hackage.haskell.org/package/first-class-families/docs/Fcf.html#t:Map","docs":"Type-level <a>fmap</a> for type-level functors.\n\nNote: this name clashes with <a>Map</a> from <i>containers</i>.\n<a>FMap</a> is provided as a synonym to avoid this.\n\n<h3><b>Example</b></h3>\n\n<pre>\n&gt;&gt;&gt; data AddMul :: Nat -&gt; Nat -&gt; Exp Nat\n\n&gt;&gt;&gt; type instance Eval (AddMul x y) = (x TL.+ y) TL.* (x TL.+ y)\n\n&gt;&gt;&gt; :kind! Eval (Map (AddMul 2) '[0, 1, 2, 3, 4])\nEval (Map (AddMul 2) '[0, 1, 2, 3, 4]) :: [Nat]\n= '[4, 9, 16, 25, 36]\n</pre>\n","type":"","module":{"name":"Fcf","url":"https://hackage.haskell.org/package/first-class-families/docs/Fcf.html"}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span>","package":{"name":"first-class-families","url":"https://hackage.haskell.org/package/first-class-families"},"url":"https://hackage.haskell.org/package/first-class-families/docs/Fcf-Class-Functor.html#t:Map","docs":"Type-level <a>fmap</a> for type-level functors.\n\nNote: this name clashes with <a>Map</a> from <i>containers</i>.\n<a>FMap</a> is provided as a synonym to avoid this.\n\n<h3><b>Example</b></h3>\n\n<pre>\n&gt;&gt;&gt; data AddMul :: Nat -&gt; Nat -&gt; Exp Nat\n\n&gt;&gt;&gt; type instance Eval (AddMul x y) = (x TL.+ y) TL.* (x TL.+ y)\n\n&gt;&gt;&gt; :kind! Eval (Map (AddMul 2) '[0, 1, 2, 3, 4])\nEval (Map (AddMul 2) '[0, 1, 2, 3, 4]) :: [Nat]\n= '[4, 9, 16, 25, 36]\n</pre>\n","type":"","module":{"name":"Fcf.Class.Functor","url":"https://hackage.haskell.org/package/first-class-families/docs/Fcf-Class-Functor.html"}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span>","package":{"name":"first-class-families","url":"https://hackage.haskell.org/package/first-class-families"},"url":"https://hackage.haskell.org/package/first-class-families/docs/Fcf-Classes.html#t:Map","docs":"Type-level <a>fmap</a> for type-level functors.\n\nNote: this name clashes with <a>Map</a> from <i>containers</i>.\n<a>FMap</a> is provided as a synonym to avoid this.\n\n<h3><b>Example</b></h3>\n\n<pre>\n&gt;&gt;&gt; data AddMul :: Nat -&gt; Nat -&gt; Exp Nat\n\n&gt;&gt;&gt; type instance Eval (AddMul x y) = (x TL.+ y) TL.* (x TL.+ y)\n\n&gt;&gt;&gt; :kind! Eval (Map (AddMul 2) '[0, 1, 2, 3, 4])\nEval (Map (AddMul 2) '[0, 1, 2, 3, 4]) :: [Nat]\n= '[4, 9, 16, 25, 36]\n</pre>\n","type":"","module":{"name":"Fcf.Classes","url":"https://hackage.haskell.org/package/first-class-families/docs/Fcf-Classes.html"}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> k v","package":{"name":"hashmap","url":"https://hackage.haskell.org/package/hashmap"},"url":"https://hackage.haskell.org/package/hashmap/docs/Data-HashMap.html#t:Map","docs":"The abstract type of a <tt>Map</tt>. Its interface is a suitable\nsubset of <a>IntMap</a>.\n","type":"","module":{"name":"Data.HashMap","url":"https://hackage.haskell.org/package/hashmap/docs/Data-HashMap.html"}},{"item":"<b>newtype</b> <span class=name><s0>Map</s0></span> a b","package":{"name":"leancheck","url":"https://hackage.haskell.org/package/leancheck"},"url":"https://hackage.haskell.org/package/leancheck/docs/Test-LeanCheck-Utils-Types.html#t:Map","docs":"Lists of pairs representing maps. The <a>Listable</a> <a>tiers</a>\nenumeration will not have repeated maps.\n\n<pre>\n&gt; take 6 (list :: [Map Nat Nat])\n[Map [],Map [(0,0)],Map [(0,1)],Map [(1,0)],Map [(0,2)],Map [(1,1)]]\n</pre>\n","type":"","module":{"name":"Test.LeanCheck.Utils.Types","url":"https://hackage.haskell.org/package/leancheck/docs/Test-LeanCheck-Utils-Types.html"}},{"item":"<span class=name><s0>Map</s0></span> :: [(a, b)] -&gt; Map a b","package":{"name":"leancheck","url":"https://hackage.haskell.org/package/leancheck"},"url":"https://hackage.haskell.org/package/leancheck/docs/Test-LeanCheck-Utils-Types.html#v:Map","docs":"","type":"","module":{"name":"Test.LeanCheck.Utils.Types","url":"https://hackage.haskell.org/package/leancheck/docs/Test-LeanCheck-Utils-Types.html"}},{"item":"<b>module</b> GI.Pango.Structs.<span class=name><s0>Map</s0></span>","package":{"name":"gi-pango","url":"https://hackage.haskell.org/package/gi-pango"},"url":"https://hackage.haskell.org/package/gi-pango/docs/GI-Pango-Structs-Map.html","docs":"<i>No description available in the introspection data.</i>\n","type":"module","module":{}},{"item":"<b>newtype</b> <span class=name><s0>Map</s0></span>","package":{"name":"gi-pango","url":"https://hackage.haskell.org/package/gi-pango"},"url":"https://hackage.haskell.org/package/gi-pango/docs/GI-Pango-Structs-Map.html#t:Map","docs":"Memory-managed wrapper type.\n","type":"","module":{"name":"GI.Pango.Structs.Map","url":"https://hackage.haskell.org/package/gi-pango/docs/GI-Pango-Structs-Map.html"}},{"item":"<span class=name><s0>Map</s0></span> :: ManagedPtr Map -&gt; Map","package":{"name":"gi-pango","url":"https://hackage.haskell.org/package/gi-pango"},"url":"https://hackage.haskell.org/package/gi-pango/docs/GI-Pango-Structs-Map.html#v:Map","docs":"","type":"","module":{"name":"GI.Pango.Structs.Map","url":"https://hackage.haskell.org/package/gi-pango/docs/GI-Pango-Structs-Map.html"}},{"item":"<span class=name><s0>Map</s0></span> :: Schema -&gt; Schema","package":{"name":"avro","url":"https://hackage.haskell.org/package/avro"},"url":"https://hackage.haskell.org/package/avro/docs/Data-Avro.html#v:Map","docs":"","type":"","module":{"name":"Data.Avro","url":"https://hackage.haskell.org/package/avro/docs/Data-Avro.html"}},{"item":"<span class=name><s0>Map</s0></span> :: HashMap Text Value -&gt; Value","package":{"name":"avro","url":"https://hackage.haskell.org/package/avro"},"url":"https://hackage.haskell.org/package/avro/docs/Data-Avro-Encoding-FromAvro.html#v:Map","docs":"","type":"","module":{"name":"Data.Avro.Encoding.FromAvro","url":"https://hackage.haskell.org/package/avro/docs/Data-Avro-Encoding-FromAvro.html"}},{"item":"<span class=name><s0>Map</s0></span> :: ReadSchema -&gt; ReadSchema","package":{"name":"avro","url":"https://hackage.haskell.org/package/avro"},"url":"https://hackage.haskell.org/package/avro/docs/Data-Avro-Schema-ReadSchema.html#v:Map","docs":"","type":"","module":{"name":"Data.Avro.Schema.ReadSchema","url":"https://hackage.haskell.org/package/avro/docs/Data-Avro-Schema-ReadSchema.html"}},{"item":"<span class=name><s0>Map</s0></span> :: Schema -&gt; Schema","package":{"name":"avro","url":"https://hackage.haskell.org/package/avro"},"url":"https://hackage.haskell.org/package/avro/docs/Data-Avro-Schema-Schema.html#v:Map","docs":"","type":"","module":{"name":"Data.Avro.Schema.Schema","url":"https://hackage.haskell.org/package/avro/docs/Data-Avro-Schema-Schema.html"}},{"item":"<b>module</b> GHC.Core.<span class=name><s0>Map</s0></span>","package":{"name":"ghc-lib-parser","url":"https://hackage.haskell.org/package/ghc-lib-parser"},"url":"https://hackage.haskell.org/package/ghc-lib-parser/docs/GHC-Core-Map.html","docs":"","type":"module","module":{}},{"item":"<b>module</b> Language.Haskell.TH.Lib.<span class=name><s0>Map</s0></span>","package":{"name":"ghc-lib-parser","url":"https://hackage.haskell.org/package/ghc-lib-parser"},"url":"https://hackage.haskell.org/package/ghc-lib-parser/docs/Language-Haskell-TH-Lib-Map.html","docs":"","type":"module","module":{}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","package":{"name":"ghc-lib-parser","url":"https://hackage.haskell.org/package/ghc-lib-parser"},"url":"https://hackage.haskell.org/package/ghc-lib-parser/docs/Language-Haskell-TH-Lib-Map.html#t:Map","docs":"","type":"","module":{"name":"Language.Haskell.TH.Lib.Map","url":"https://hackage.haskell.org/package/ghc-lib-parser/docs/Language-Haskell-TH-Lib-Map.html"}},{"item":"<b>module</b> Data.GenValidity.<span class=name><s0>Map</s0></span>","package":{"name":"genvalidity-containers","url":"https://hackage.haskell.org/package/genvalidity-containers"},"url":"https://hackage.haskell.org/package/genvalidity-containers/docs/Data-GenValidity-Map.html","docs":"","type":"module","module":{}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> measA vertA horizA measB vertB horizB height width","package":{"name":"lapack","url":"https://hackage.haskell.org/package/lapack"},"url":"https://hackage.haskell.org/package/lapack/docs/Numeric-LAPACK-Matrix-Extent.html#t:Map","docs":"","type":"","module":{"name":"Numeric.LAPACK.Matrix.Extent","url":"https://hackage.haskell.org/package/lapack/docs/Numeric-LAPACK-Matrix-Extent.html"}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","package":{"name":"postgresql-binary","url":"https://hackage.haskell.org/package/postgresql-binary"},"url":"https://hackage.haskell.org/package/postgresql-binary/docs/PostgreSQL-Binary-Data.html#t:Map","docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n\nThe <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which\nprefers values from the left operand. If <tt>m1</tt> maps a key\n<tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key\nto a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;\nm2</tt> maps <tt>k</tt> to <tt>a1</tt>.\n","type":"","module":{"name":"PostgreSQL.Binary.Data","url":"https://hackage.haskell.org/package/postgresql-binary/docs/PostgreSQL-Binary-Data.html"}},{"item":"<b>module</b> Rebase.Data.<span class=name><s0>Map</s0></span>","package":{"name":"rebase","url":"https://hackage.haskell.org/package/rebase"},"url":"https://hackage.haskell.org/package/rebase/docs/Rebase-Data-Map.html","docs":"","type":"module","module":{}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","package":{"name":"rebase","url":"https://hackage.haskell.org/package/rebase"},"url":"https://hackage.haskell.org/package/rebase/docs/Rebase-Prelude.html#t:Map","docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n\nThe <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which\nprefers values from the left operand. If <tt>m1</tt> maps a key\n<tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key\nto a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;\nm2</tt> maps <tt>k</tt> to <tt>a1</tt>.\n","type":"","module":{"name":"Rebase.Prelude","url":"https://hackage.haskell.org/package/rebase/docs/Rebase-Prelude.html"}},{"item":"<b>module</b> Data.Validity.<span class=name><s0>Map</s0></span>","package":{"name":"validity-containers","url":"https://hackage.haskell.org/package/validity-containers"},"url":"https://hackage.haskell.org/package/validity-containers/docs/Data-Validity-Map.html","docs":"","type":"module","module":{}},{"item":"<b>module</b> Agda.Utils.<span class=name><s0>Map</s0></span>","package":{"name":"Agda","url":"https://hackage.haskell.org/package/Agda"},"url":"https://hackage.haskell.org/package/Agda/docs/Agda-Utils-Map.html","docs":"","type":"module","module":{}},{"item":"<b>type family</b> <span class=name><s0>Map</s0></span> (f :: Function k l -&gt; Type) (as :: [k]) :: [l]","package":{"name":"Agda","url":"https://hackage.haskell.org/package/Agda"},"url":"https://hackage.haskell.org/package/Agda/docs/Agda-Utils-TypeLevel.html#t:Map","docs":"","type":"","module":{"name":"Agda.Utils.TypeLevel","url":"https://hackage.haskell.org/package/Agda/docs/Agda-Utils-TypeLevel.html"}},{"item":"<b>module</b> Data.Bijection.<span class=name><s0>Map</s0></span>","package":{"name":"bimaps","url":"https://hackage.haskell.org/package/bimaps"},"url":"https://hackage.haskell.org/package/bimaps/docs/Data-Bijection-Map.html","docs":"Bijections via strict maps.\n","type":"module","module":{}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","package":{"name":"bimaps","url":"https://hackage.haskell.org/package/bimaps"},"url":"https://hackage.haskell.org/package/bimaps/docs/Data-Bijection-Map.html#t:Map","docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n","type":"","module":{"name":"Data.Bijection.Map","url":"https://hackage.haskell.org/package/bimaps/docs/Data-Bijection-Map.html"}},{"item":"<b>module</b> Network.Wai.Session.<span class=name><s0>Map</s0></span>","package":{"name":"wai-session","url":"https://hackage.haskell.org/package/wai-session"},"url":"https://hackage.haskell.org/package/wai-session/docs/Network-Wai-Session-Map.html","docs":"","type":"module","module":{}},{"item":"<b>module</b> Opaleye.Internal.<span class=name><s0>Map</s0></span>","package":{"name":"opaleye","url":"https://hackage.haskell.org/package/opaleye"},"url":"https://hackage.haskell.org/package/opaleye/docs/Opaleye-Internal-Map.html","docs":"","type":"module","module":{}},{"item":"<b>type family</b> <span class=name><s0>Map</s0></span> f x","package":{"name":"opaleye","url":"https://hackage.haskell.org/package/opaleye"},"url":"https://hackage.haskell.org/package/opaleye/docs/Opaleye-Internal-Map.html#t:Map","docs":"","type":"","module":{"name":"Opaleye.Internal.Map","url":"https://hackage.haskell.org/package/opaleye/docs/Opaleye-Internal-Map.html"}},{"item":"<b>module</b> Opaleye.<span class=name><s0>Map</s0></span>","package":{"name":"opaleye","url":"https://hackage.haskell.org/package/opaleye"},"url":"https://hackage.haskell.org/package/opaleye/docs/Opaleye-Map.html","docs":"<i>Deprecated: This module will be removed in 0.8.</i>\n","type":"module","module":{}},{"item":"<b>module</b> Toml.Codec.Combinator.<span class=name><s0>Map</s0></span>","package":{"name":"tomland","url":"https://hackage.haskell.org/package/tomland"},"url":"https://hackage.haskell.org/package/tomland/docs/Toml-Codec-Combinator-Map.html","docs":"TOML-specific combinators for converting between TOML and Haskell\nMap-like data types.\n\nThere are two way to represent map-like structures with the\n<tt>tomland</tt> library.\n\n<ul>\n<li>Map structure with the key and value represented as key-value\npairs:<pre>foo = [ {myKey = \"name\", myVal = 42} , {myKey =\n\"otherName\", myVal = 100} ] </pre></li>\n<li>Map structure as a table with the <tt>TOML</tt> key as the map\nkey:<pre>[foo] name = 42 otherName = 100 </pre></li>\n</ul>\n\nYou can find both types of the codecs in this module for different\nmap-like structures. See the following table for the heads up:\n\nTODO: table\n\n<b>Note:</b> in case of the missing key on the <tt>TOML</tt> side an\nempty map structure is returned.\n","type":"module","module":{}},{"item":"<b>module</b> Numeric.<span class=name><s0>Map</s0></span>","package":{"name":"algebra","url":"https://hackage.haskell.org/package/algebra"},"url":"https://hackage.haskell.org/package/algebra/docs/Numeric-Map.html","docs":"","type":"module","module":{}},{"item":"<b>newtype</b> <span class=name><s0>Map</s0></span> r b a","package":{"name":"algebra","url":"https://hackage.haskell.org/package/algebra"},"url":"https://hackage.haskell.org/package/algebra/docs/Numeric-Map.html#t:Map","docs":"linear maps from elements of a free module to another free module over\nr\n\n<pre>\nf $# x + y = (f $# x) + (f $# y)\nf $# (r .* x) = r .* (f $# x)\n</pre>\n\n<tt>Map r b a</tt> represents a linear mapping from a free module with\nbasis <tt>a</tt> over <tt>r</tt> to a free module with basis\n<tt>b</tt> over <tt>r</tt>.\n\nNote well the reversed direction of the arrow, due to the\ncontravariance of change of basis!\n\nThis way enables we can employ arbitrary pure functions as linear maps\nby lifting them using <a>arr</a>, or build them by using the monad\ninstance for Map r b. As a consequence Map is an instance of, well,\nalmost everything.\n","type":"","module":{"name":"Numeric.Map","url":"https://hackage.haskell.org/package/algebra/docs/Numeric-Map.html"}},{"item":"<span class=name><s0>Map</s0></span> :: ((a -&gt; r) -&gt; b -&gt; r) -&gt; Map r b a","package":{"name":"algebra","url":"https://hackage.haskell.org/package/algebra"},"url":"https://hackage.haskell.org/package/algebra/docs/Numeric-Map.html#v:Map","docs":"","type":"","module":{"name":"Numeric.Map","url":"https://hackage.haskell.org/package/algebra/docs/Numeric-Map.html"}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> c","package":{"name":"apecs","url":"https://hackage.haskell.org/package/apecs"},"url":"https://hackage.haskell.org/package/apecs/docs/Apecs.html#t:Map","docs":"A map based on <a>Strict</a>. O(log(n)) for most operations.\n","type":"","module":{"name":"Apecs","url":"https://hackage.haskell.org/package/apecs/docs/Apecs.html"}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> c","package":{"name":"apecs","url":"https://hackage.haskell.org/package/apecs"},"url":"https://hackage.haskell.org/package/apecs/docs/Apecs-Stores.html#t:Map","docs":"A map based on <a>Strict</a>. O(log(n)) for most operations.\n","type":"","module":{"name":"Apecs.Stores","url":"https://hackage.haskell.org/package/apecs/docs/Apecs-Stores.html"}},{"item":"<span class=name><s0>Map</s0></span> :: (a -&gt; b) -&gt; (b -&gt; a) -&gt; (b :-&gt; c) -&gt; a :-&gt; c","package":{"name":"hedgehog-fn","url":"https://hackage.haskell.org/package/hedgehog-fn"},"url":"https://hackage.haskell.org/package/hedgehog-fn/docs/Hedgehog-Function-Internal.html#v:Map","docs":"","type":"","module":{"name":"Hedgehog.Function.Internal","url":"https://hackage.haskell.org/package/hedgehog-fn/docs/Hedgehog-Function-Internal.html"}},{"item":"<b>type family</b> <span class=name><s0>Map</s0></span> (a_a8R94 :: (~&gt;) a_a8QHY b_a8QHZ) (a_a8R95 :: NonEmpty a_a8QHY) :: NonEmpty b_a8QHZ","package":{"name":"singletons-base","url":"https://hackage.haskell.org/package/singletons-base"},"url":"https://hackage.haskell.org/package/singletons-base/docs/Data-List-NonEmpty-Singletons.html#t:Map","docs":"","type":"","module":{"name":"Data.List.NonEmpty.Singletons","url":"https://hackage.haskell.org/package/singletons-base/docs/Data-List-NonEmpty-Singletons.html"}},{"item":"<b>type family</b> <span class=name><s0>Map</s0></span> (a_a16KN :: (~&gt;) a_a16Hw b_a16Hx) (a_a16KO :: [a_a16Hw]) :: [b_a16Hx]","package":{"name":"singletons-base","url":"https://hackage.haskell.org/package/singletons-base"},"url":"https://hackage.haskell.org/package/singletons-base/docs/Data-List-Singletons.html#t:Map","docs":"","type":"","module":{"name":"Data.List.Singletons","url":"https://hackage.haskell.org/package/singletons-base/docs/Data-List-Singletons.html"}},{"item":"<b>type family</b> <span class=name><s0>Map</s0></span> (a_a16KN :: (~&gt;) a_a16Hw b_a16Hx) (a_a16KO :: [a_a16Hw]) :: [b_a16Hx]","package":{"name":"singletons-base","url":"https://hackage.haskell.org/package/singletons-base"},"url":"https://hackage.haskell.org/package/singletons-base/docs/Prelude-Singletons.html#t:Map","docs":"","type":"","module":{"name":"Prelude.Singletons","url":"https://hackage.haskell.org/package/singletons-base/docs/Prelude-Singletons.html"}},{"item":"<b>module</b> Data.Monoid.<span class=name><s0>Map</s0></span>","package":{"name":"stack","url":"https://hackage.haskell.org/package/stack"},"url":"https://hackage.haskell.org/package/stack/docs/Data-Monoid-Map.html","docs":"","type":"module","module":{}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","package":{"name":"stack","url":"https://hackage.haskell.org/package/stack"},"url":"https://hackage.haskell.org/package/stack/docs/Stack-Prelude.html#t:Map","docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n\nThe <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which\nprefers values from the left operand. If <tt>m1</tt> maps a key\n<tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key\nto a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;\nm2</tt> maps <tt>k</tt> to <tt>a1</tt>.\n","type":"","module":{"name":"Stack.Prelude","url":"https://hackage.haskell.org/package/stack/docs/Stack-Prelude.html"}},{"item":"<b>module</b> Data.Express.<span class=name><s0>Map</s0></span>","package":{"name":"express","url":"https://hackage.haskell.org/package/express"},"url":"https://hackage.haskell.org/package/express/docs/Data-Express-Map.html","docs":"Utilities for mapping or transforming <a>Expr</a>s.\n","type":"module","module":{}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> κ ν","package":{"name":"core-data","url":"https://hackage.haskell.org/package/core-data"},"url":"https://hackage.haskell.org/package/core-data/docs/Core-Data-Structures.html#t:Map","docs":"A mapping from keys to values.\n\nThe keys in a map needs to be an instance of the <a>Key</a> typeclass.\nInstances are already provided for many common element types.\n\n<a>Map</a> implements <a>Foldable</a>, <a>Monoid</a>, etc so many\ncommon operations such as <a>foldr</a> to reduce the structure with a\nright fold, <a>length</a> to get the number of key/value pairs in the\ndictionary, <a>null</a> to test whether the map is empty, and\n(<a>&lt;&gt;</a>) to join two maps together are available.\n\nTo convert to other dictionary types see <a>fromMap</a> below.\n\n(this is a thin wrapper around <b>unordered-containers</b>'s\n<a>HashMap</a>, but if you use the conversion functions to extract the\nkey/value pairs in a list the list will be ordered according to the\nkeys' <a>Ord</a> instance)\n","type":"","module":{"name":"Core.Data.Structures","url":"https://hackage.haskell.org/package/core-data/docs/Core-Data-Structures.html"}},{"item":"<b>module</b> Control.Concurrent.<span class=name><s0>Map</s0></span>","package":{"name":"ctrie","url":"https://hackage.haskell.org/package/ctrie"},"url":"https://hackage.haskell.org/package/ctrie/docs/Control-Concurrent-Map.html","docs":"A non-blocking concurrent map from hashable keys to values.\n\nThe implementation is based on <i>lock-free concurrent hash tries</i>\n(aka <i>Ctries</i>) as described by:\n\n<ul>\n<li>Aleksander Prokopec, Phil Bagwell, Martin Odersky, \"<i>Cache-Aware\nLock-Free Concurent Hash Tries</i>\"</li>\n<li>Aleksander Prokopec, Nathan G. Bronson, Phil Bagwell, Martin\nOdersky \"<i>Concurrent Tries with Efficient Non-Blocking\nSnapshots</i>\"</li>\n</ul>\n\nOperations have a worst-case complexity of <i>O(log n)</i>, with a\nbase equal to the size of the native <a>Word</a>.\n","type":"module","module":{}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> k v","package":{"name":"ctrie","url":"https://hackage.haskell.org/package/ctrie"},"url":"https://hackage.haskell.org/package/ctrie/docs/Control-Concurrent-Map.html#t:Map","docs":"A map from keys <tt>k</tt> to values <tt>v</tt>.\n","type":"","module":{"name":"Control.Concurrent.Map","url":"https://hackage.haskell.org/package/ctrie/docs/Control-Concurrent-Map.html"}},{"item":"<b>module</b> Cursor.<span class=name><s0>Map</s0></span>","package":{"name":"cursor","url":"https://hackage.haskell.org/package/cursor"},"url":"https://hackage.haskell.org/package/cursor/docs/Cursor-Map.html","docs":"","type":"module","module":{}},{"item":"<b>module</b> Cursor.Simple.<span class=name><s0>Map</s0></span>","package":{"name":"cursor","url":"https://hackage.haskell.org/package/cursor"},"url":"https://hackage.haskell.org/package/cursor/docs/Cursor-Simple-Map.html","docs":"","type":"module","module":{}},{"item":"<span class=name><s0>Map</s0></span> :: EDNMap -&gt; Value","package":{"name":"hedn","url":"https://hackage.haskell.org/package/hedn"},"url":"https://hackage.haskell.org/package/hedn/docs/Data-EDN.html#v:Map","docs":"<pre>\n{:a map}\n</pre>\n","type":"","module":{"name":"Data.EDN","url":"https://hackage.haskell.org/package/hedn/docs/Data-EDN.html"}},{"item":"<span class=name><s0>Map</s0></span> :: EDNMap -&gt; Value","package":{"name":"hedn","url":"https://hackage.haskell.org/package/hedn"},"url":"https://hackage.haskell.org/package/hedn/docs/Data-EDN-AST-Types-Value.html#v:Map","docs":"<pre>\n{:a map}\n</pre>\n","type":"","module":{"name":"Data.EDN.AST.Types.Value","url":"https://hackage.haskell.org/package/hedn/docs/Data-EDN-AST-Types-Value.html"}},{"item":"<b>module</b> Data.RangeSet.<span class=name><s0>Map</s0></span>","package":{"name":"range-set-list","url":"https://hackage.haskell.org/package/range-set-list"},"url":"https://hackage.haskell.org/package/range-set-list/docs/Data-RangeSet-Map.html","docs":"A slightly less trivial implementation of range sets.\n\nThis is nearly identical to <a>Data.RangeSet.List</a> except for some\nimportant performance differences:\n\n<ul>\n<li>Most query functions in this module are <i>O(log n)</i> rather\nthan <i>O(n)</i>, so may be much faster.</li>\n<li>Most composition functions have the same time complexity but a\nhigher constant, so may be somewhat slower.</li>\n</ul>\n\nIf you're mainly calling <a>member</a>, you should consider using this\nmodule, but if you're calling <a>union</a>, <a>deleteRange</a>, and\nother range manipulation functions as often as querying, you might\nstick with the list implementation.\n\nThis module is intended to be imported qualified, to avoid name\nclashes with Prelude functions, e.g.\n\n<pre>\nimport Data.RangeSet.Map (RSet)\nimport qualified Data.RangeSet.Map as RSet\n</pre>\n\nThe implementation of <a>RSet</a> is based on <a>Data.Map.Strict</a>.\n","type":"module","module":{}},{"item":"<b>module</b> Synthesizer.Dimensional.<span class=name><s0>Map</s0></span>","package":{"name":"synthesizer-dimensional","url":"https://hackage.haskell.org/package/synthesizer-dimensional"},"url":"https://hackage.haskell.org/package/synthesizer-dimensional/docs/Synthesizer-Dimensional-Map.html","docs":"Maps that handle pairs of amplitudes and sampled values. They are a\nspecial form of arrows.\n","type":"module","module":{}},{"item":"<span class=name><s0>Map</s0></span> :: Element &quot;map&quot; &#39;[Flow, Phrasing, Palpable] (Flow :|: (Phrasing :|: Palpable)) (NameA &amp; &#39;[])","package":{"name":"type-of-html","url":"https://hackage.haskell.org/package/type-of-html"},"url":"https://hackage.haskell.org/package/type-of-html/docs/Html-Type.html#v:Map","docs":"4.8.13\n","type":"","module":{"name":"Html.Type","url":"https://hackage.haskell.org/package/type-of-html/docs/Html-Type.html"}},{"item":"<b>package</b> <span class=name><s0>Map</s0></span>","package":{},"url":"https://hackage.haskell.org/package/Map","docs":"Not on Stackage, so not searched.\nClass of key-value maps\n","type":"package","module":{}},{"item":"<span class=name><s0>Map</s0></span> :: [(Literal, Literal)] -&gt; Literal","package":{"name":"codec-beam","url":"https://hackage.haskell.org/package/codec-beam"},"url":"https://hackage.haskell.org/package/codec-beam/docs/Codec-Beam.html#v:Map","docs":"","type":"","module":{"name":"Codec.Beam","url":"https://hackage.haskell.org/package/codec-beam/docs/Codec-Beam.html"}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","package":{"name":"intro","url":"https://hackage.haskell.org/package/intro"},"url":"https://hackage.haskell.org/package/intro/docs/Intro.html#t:Map","docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n","type":"","module":{"name":"Intro","url":"https://hackage.haskell.org/package/intro/docs/Intro.html"}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> ph k v","package":{"name":"justified-containers","url":"https://hackage.haskell.org/package/justified-containers"},"url":"https://hackage.haskell.org/package/justified-containers/docs/Data-Map-Justified.html#t:Map","docs":"A <a>Data.Map</a> <tt><a>Map</a></tt> wrapper that allows direct\nlookup of keys that are known to exist in the map.\n\nHere, \"direct lookup\" means that once a key has been proven to exist\nin the map, it can be used to extract a value directly from the map,\nrather than requiring a <tt><a>Maybe</a></tt> layer.\n\n<tt><a>Map</a></tt> allows you to shift the burden of proof that a key\nexists in a map from \"prove at every lookup\" to \"prove once per key\".\n","type":"","module":{"name":"Data.Map.Justified","url":"https://hackage.haskell.org/package/justified-containers/docs/Data-Map-Justified.html"}},{"item":"<span class=name><s0>Map</s0></span> :: Schema -&gt; Schema","package":{"name":"language-avro","url":"https://hackage.haskell.org/package/language-avro"},"url":"https://hackage.haskell.org/package/language-avro/docs/Language-Avro-Types.html#v:Map","docs":"","type":"","module":{"name":"Language.Avro.Types","url":"https://hackage.haskell.org/package/language-avro/docs/Language-Avro-Types.html"}},{"item":"<b>module</b> Data.Loc.Internal.<span class=name><s0>Map</s0></span>","package":{"name":"loc","url":"https://hackage.haskell.org/package/loc"},"url":"https://hackage.haskell.org/package/loc/docs/Data-Loc-Internal-Map.html","docs":"","type":"module","module":{}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","package":{"name":"loc","url":"https://hackage.haskell.org/package/loc"},"url":"https://hackage.haskell.org/package/loc/docs/Data-Loc-Internal-Prelude.html#t:Map","docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n\nThe <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which\nprefers values from the left operand. If <tt>m1</tt> maps a key\n<tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key\nto a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;\nm2</tt> maps <tt>k</tt> to <tt>a1</tt>.\n","type":"","module":{"name":"Data.Loc.Internal.Prelude","url":"https://hackage.haskell.org/package/loc/docs/Data-Loc-Internal-Prelude.html"}},{"item":"<b>module</b> Control.Monad.Trans.Memo.<span class=name><s0>Map</s0></span>","package":{"name":"monad-memo","url":"https://hackage.haskell.org/package/monad-memo"},"url":"https://hackage.haskell.org/package/monad-memo/docs/Control-Monad-Trans-Memo-Map.html","docs":"Specialization of <a>MemoStateT</a> with <a>Map</a> as a container\n","type":"module","module":{}},{"item":"<b>newtype</b> <span class=name><s0>Map</s0></span>","package":{"name":"text-region","url":"https://hackage.haskell.org/package/text-region"},"url":"https://hackage.haskell.org/package/text-region/docs/Data-Text-Region-Types.html#t:Map","docs":"Main idea is that there are only two basic actions, that changes\nregions: inserting and cutting When something is cutted out or\ninserted in, <a>Region</a> positions must be updated All editings can\nbe represented as many cuts and inserts, so we can combine them to get\nfunction which maps source regions to regions on updated data Because\ninsert is dual to cut (and therefore composes something like iso), we\ncan also get function to map regions back Combining this functions\nwhile edit, we get function, that maps regions from source data to\nedited one To get back function, we must also combine opposite\nactions, or we can represent actions as <a>Iso</a> Same idea goes for\nmodifying contents, represent each action as isomorphism and combine\nthem together This works if we don't use overlapped regions\n","type":"","module":{"name":"Data.Text.Region.Types","url":"https://hackage.haskell.org/package/text-region/docs/Data-Text-Region-Types.html"}},{"item":"<span class=name><s0>Map</s0></span> :: Iso&#39; Region Region -&gt; Map","package":{"name":"text-region","url":"https://hackage.haskell.org/package/text-region"},"url":"https://hackage.haskell.org/package/text-region/docs/Data-Text-Region-Types.html#v:Map","docs":"","type":"","module":{"name":"Data.Text.Region.Types","url":"https://hackage.haskell.org/package/text-region/docs/Data-Text-Region-Types.html"}},{"item":"<b>module</b> Data.TypeMap.Internal.<span class=name><s0>Map</s0></span>","package":{"name":"type-map","url":"https://hackage.haskell.org/package/type-map"},"url":"https://hackage.haskell.org/package/type-map/docs/Data-TypeMap-Internal-Map.html","docs":"","type":"module","module":{}},{"item":"<b>module</b> Data.TypeMap.<span class=name><s0>Map</s0></span>","package":{"name":"type-map","url":"https://hackage.haskell.org/package/type-map"},"url":"https://hackage.haskell.org/package/type-map/docs/Data-TypeMap-Map.html","docs":"","type":"module","module":{}},{"item":"<b>type family</b> <span class=name><s0>Map</s0></span> (f :: Type -&gt; Type) (xs :: [Type]) :: [Type]","package":{"name":"first-class-patterns","url":"https://hackage.haskell.org/package/first-class-patterns"},"url":"https://hackage.haskell.org/package/first-class-patterns/docs/Data-Pattern-Base-Tuple.html#t:Map","docs":"","type":"","module":{"name":"Data.Pattern.Base.Tuple","url":"https://hackage.haskell.org/package/first-class-patterns/docs/Data-Pattern-Base-Tuple.html"}},{"item":"<span class=name><s0>Map</s0></span> :: ExprSpec -&gt; InputSpec -&gt; OutputSpec -&gt; HawkSpec","package":{"name":"haskell-awk","url":"https://hackage.haskell.org/package/haskell-awk"},"url":"https://hackage.haskell.org/package/haskell-awk/docs/System-Console-Hawk-Args-Spec.html#v:Map","docs":"","type":"","module":{"name":"System.Console.Hawk.Args.Spec","url":"https://hackage.haskell.org/package/haskell-awk/docs/System-Console-Hawk-Args-Spec.html"}},{"item":"<span class=name><s0>Map</s0></span> :: (IsSequence s) =&gt; (Exp a -&gt; Exp b) -&gt; Exp s -&gt; Exp (Sequence b)","package":{"name":"rethinkdb-client-driver","url":"https://hackage.haskell.org/package/rethinkdb-client-driver"},"url":"https://hackage.haskell.org/package/rethinkdb-client-driver/docs/Database-RethinkDB.html#v:Map","docs":"","type":"","module":{"name":"Database.RethinkDB","url":"https://hackage.haskell.org/package/rethinkdb-client-driver/docs/Database-RethinkDB.html"}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> k a","package":{"name":"tonalude","url":"https://hackage.haskell.org/package/tonalude"},"url":"https://hackage.haskell.org/package/tonalude/docs/Tonalude.html#t:Map","docs":"A Map from keys <tt>k</tt> to values <tt>a</tt>.\n\nThe <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which\nprefers values from the left operand. If <tt>m1</tt> maps a key\n<tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key\nto a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;\nm2</tt> maps <tt>k</tt> to <tt>a1</tt>.\n","type":"","module":{"name":"Tonalude","url":"https://hackage.haskell.org/package/tonalude/docs/Tonalude.html"}},{"item":"<b>module</b> Control.Concurrent.STM.<span class=name><s0>Map</s0></span>","package":{"name":"ttrie","url":"https://hackage.haskell.org/package/ttrie"},"url":"https://hackage.haskell.org/package/ttrie/docs/Control-Concurrent-STM-Map.html","docs":"A contention-free STM hash map. \"Contention-free\" means that the map\nwill never cause spurious conflicts. A transaction operating on the\nmap will only ever have to retry if another transaction is operating\non the same key at the same time.\n","type":"module","module":{}},{"item":"<b>data</b> <span class=name><s0>Map</s0></span> k v","package":{"name":"ttrie","url":"https://hackage.haskell.org/package/ttrie"},"url":"https://hackage.haskell.org/package/ttrie/docs/Control-Concurrent-STM-Map.html#t:Map","docs":"A map from keys <tt>k</tt> to values <tt>v</tt>.\n","type":"","module":{"name":"Control.Concurrent.STM.Map","url":"https://hackage.haskell.org/package/ttrie/docs/Control-Concurrent-STM-Map.html"}}]